Article summary:
	It covers 101 key aspects of ethereum
	I will be notetaking the key aspects that I didn't know of
1
	Ethereum is 'a next-generation smart contract and decentralized application platform'
2
	Ethereum is a blockchain with a built-in turing-complete programming language, allowing anyone to write to smart contracts
	  and decentralized applications where they can create their own arbitrary rules for ownership, TX formats and state 
	  transition functions
3
	Ethereum is an open source, globally decentralized computing infrastructure
	It uses a blockchain to synchronize and store the systems state changes
	It has a cryptocurrency called 'ether' which is used to meter and constrain execution resource costs
4
	Provides dApps with
		High availability
		High auditability
		High transparency
		High neutrality
	Reduces/eliminates
		Censorship
		Counterparty risk
5
	Ethereum is not made to be a currency payment network
	Ether is intended to be a utility currency to pay for use of the ethereum platform to compute
6
	Unlike Bitcoin, which has a very limited scripting language, Ethereum is designed to be a general-purpose programmable 
	  blockchain that runs a virtual machine capable of executing code of arbitrary and unbounded complexity
	Where Bitcoin's Script language is (intentionally) constrained to simple true/false evaluation of spending conditions, Ethereums
	  language is turing complete, meaning that Ethereum can straightforwardly function as a general-purspose computer
7
	The original blockchain (Bitcoin blockchain) tracks the state of units of bitcoin and their ownership
	Bitcoin can be thought of as a distributed consensus machine, where TXs cause a global state transition, altering the ownership
	  of coins
	The state transitions are constrained by the rules of consensus, allowing all participants to (eventually) converge on a 
	  common (consensus) state of the system, after several blocks are mined
	Ethereum is also a distributed state machine
	Instead of tracking only the state of currency ownership, Ethereum tracks the satet transitions of a general-purpose data store
	  (IE: a store that can hold any data expressible as a key-value tuple)
8
	Ethereums core components
		P2P network
			Ethereum runs on the Ethereum main network which is addressable on TCP port 30303
			Runs a protocol called ÐΞVp2p
		Transactions
			Ethereum transactions are network messages that include (among other things)
				Sender
				Recipient
				Value
				Data payload
		State machine
			Ethereum state transitions are processed by the Ethereum virtual machine (EVM)
			EMN programs called 'smart contracts' are written in high-level languages (solidity, vyper)
			These smart contracts are compiled to bytecode for execution on the EVM
		Data structures
			Ethereums state is stored locally on each node as a database (usually Google's LevelDB)
			It contains the transactions and system state in a serialized hashed data structure
			That data structure is called a Merkle Patricia Tree
9
	Ethereums core components (continued)
		Consensus algorithm
			Ethereum uses Bitcoin's consensus model, the 'Nakamoto Consensus'
			Uses sequential single-signature blocks, weighted in importance by Proof-Of-Work (POW)
			The longest chain is the current state
			In ethereum 2.0 this is being transitioned to a Proof-Of-Stake in Ethereum 2.0 (which is out now)
		Clients
			Ethereum has several interoperable implementations of the client software
				OpenEthereum
				Erigon
				Nethermind
				Turbo-geth
10
	Ethereums abilitiy to execute a stored program, in a state machine called the 'Ethereum Virtual Machine' (EVM), while reading
	  and writing data to memory makes it a turing-complete system
	Turing-complete systems face the challenge of the halting problem (IE: given an arbitrary program and its input, it is not 
	  solvable to determine whether the program will eventually stop running)
11
	Each instruction has a gas cost
	When a transaction is triggered, an amount of gas is specified and that is the upper limit of what can be consumed
	The EVM will terminate the execution if the amount of gas exceeds the gas set in the transaction	
12
	Ether needs to be send along with a transaction and it needs to be marked for the purchase of gas
	Along with an acceptable gas price
	The price of gas is not fixed. Gas is purchased for the transaction, the computation is executed. Unused gas is refunded
13
	A decentralized application (ÐApp) is a web application that is built on top of open, decentralized peer-to-peer infrastructure
	Typically combines smart contracts with a web interface
14
	ÐApps represent a transition from 'web2' to 'web3' where applications are built on decentralized P2P protocols for
		Compute
		Storage
		Messaging
15
	Ethereum represents the decentralized compute part of the 'web3'
	Swarm represents the decentralized storage
	Whisper (now Waku) represents the decentralized messaging protocol
16
	Decentralization can be considered as three types
		Architectural decentralization
		Political decentralization
		Logical decentralization
17
	Ethereums currency unit is called 'ether' or 'ETH'
	Ether is subdivided into smaller units and the smallest unit is 'wei'
		10**3 'wei' is 1 'babbage'
		10**6 'wei' is one 'lovelace'
		10**9 'wei' is one 'shannon'
		10**18 'wei' is one 'ether'
18	
	Ethereum uses public key cryptography to create public-private key pairs whic are used for digital signatures
19
	Ethereum uses Elliptic Curve Digital Signature Algorithm (ECDSA) for digital signatures (SECP-256k1 curve)
	This is based on elliptic-curve cryptography (ECC)
	It is an approach to public-key cryptography based on algebraic structure of elliptic curves over finite fields
20
	An ethereum private key is a 256-bit random number that uniquely determines a single ethereum address also known as an account
21
	An ethereum public key is a point on an elliptic curve calculated from the private key using elliptic curve manipulation
	Can't get the private key by analyzing the public key
22
	Ethereum state is made up of objects called 'accounts', with each account having 20-byte address
	State transitions being direct transfers of value and information between accounts
23
	Ethereum account contains four fields
		The nonce, a counter used to make sure each transaction can only be processed once
		The accounts curreny ether balance
		The accounts contract code (if present)
		The accounts storage (empty by default)
24
	Ethereum as two different account types
		Externally owned accounts (EOAs) controlled by private keys
		Contract accounts controlled by their contract code
25
	Ownership of ether by EOAs is established through private keys, Ethereum addresses, and digital signatures
	Anyone with a private key has control of the corresponding EOA account and any ether it holds
26
	An EOA has no code, and one can send messages from an EOA by creating and signing a transaction
27
	A contract account has code and associated storage and every time in recieves a message its code activates
	This allows it to read and write to internal storage and setnd other messages or create contracts in turn
28
	Smart contracts can be thought of as 'autonomous agents' that live inside of the Ethereum execution environment
	The always execute a specificp piece of code when 'poked' by a message or transaction
29	
	Ethereum uses Keccak-256 as its cryptographic hash function
	Keccak-256 was the winning candidate for the SHA-3 competition held by NIST but is different from the final SHA-3 standard
30
	The ethereum address of an EOA is the last 20 bytes (least significant bytes) of the Keccak-256 hash of the public key 
	of the EOA's key pair
	Here is the full chain
		Privatekey generates publickey
		Keccak256 the publickey
		Last 20 bytes of the hash result is the address (the least significant bytes)
31
	Transactions are signed messages that come from EOA, transmitted by the Ethereum network, recorded on the Ethereum blockchain
	Only TXs can trigger a change of state
	Ethereum is a transaction-based state machine
32
	Ethereum TX properties
		Atomic
			All or nothing. Happens or doesn't. Cannot be divided or interrupted by other transactions
		Serial
			Transactions are processed sequentially one after the other without any overlapping by other TXs
		Inclusion
			TX inclusion is not guaranteed and depends on network congustion and gasPrice among other things	
			Miners determine inclusion
		Order
			TX order is not guaranteed and depends on network congustion and gasPrice
			Miners determine order
33
	A transaction is a serialized binary message that contains the following components
		1) Nonce: A sequence number issued by the originating EOA, used to prevent message replay
		2) gasPrice: The amount of ether (in wei) that the originator is willing to pay for each unit of gas
		3) gasLimit: The maximum amount of gas the originator is willing to pay for this transaction
		4) recipient: The destination Ethereum address
		5) value: The amount of ether (in wei) to send to the destination
		6) data: The variable-length binary data payload
		7) v,r,s: The three components of an ECDSA digital signature of the originating EOA
34
	Nonce is a scalar value equal to the number of TXs sent from the EOA account
	In the case of contract accounts it is the number of contract creations made by the account
35
	Gas price is the price a TX originator is willing to pay in exchange for gas
	The price is measured in 'wei' per gas unit
	The higher the gas price, the faster the TX is likely to be confirmed on the blockchain
	The suggested gas price depends on thedomand for block space at the time of the transaction
36
	Gas limit is the maximum number of gas units the transaction originator is willing to pay in order to complete the transaction
37
	Recipient is the 20-byte ethereum address of the transactions recipient which can be an EOA or a contract account
		1) The Ethereum protocol does not validate the recipient addresses in transactions
		   This means you can send a TX to an address that has no private key or contract
		   Don't make mistakes
		2) Note that there is no 'from' address in the TX because the EOA's public key can be derived
		   from the v,r,s components of the ECDSA signature and the transaction sender's address found from this public key
38
	Value is the amount of ether sent to the transactions recipient
	If the repicient is an EOA then the balance will be increased by this amount
	If recipeint is a contract it depeonds on the TX data
	If no TX data then the contracts fallback recieve() or fallback() function will be triggered if present
	Depending on how those functions are written, the contract can accept the ether or trigger an exception
39
	Data is the information (typically) sent to a contract account indication the contract's function to be called
	It also contains the arguments needed for that function to run
40
	v,r,s:
		'r' and 's' are the two parts of the ECDSA signature produced by the TX sender using the private key
		'v' is the recovery identifier which is caluclated as either one of 27 or 28, or as the chain ID doubled plus 35 or 36
			Ethereum mainnet chainID is 1
41
	A digital signature serves three purposes in Ethereum
		1) Proves that the owner of the private key (who by implication is the owner of the account) has authorized
		   the spending of ether or execution of a contract
		2) Guarantees non-repudiation (the proof of the authorization is undeniable)
		3) Proves that the TX data has not been and cannot be modified by anyone after the TX has been signed
42	
	Contract creation TXs are sent to a special destination address called the 'zero adderss' (address 0x0)
	A contract creation TX contains a data payload with the compiled bytecode to create the contract
	An optional ether amount in the value field will create the new contract with a starting balance
43
	TXs vs messages
		1) A TX is produces by an EOA where as external actor sends a signed data package with either:
			1) Triggers a message to another EOA where it leads to a transfer of value
			2) Triggers a message to a contract account where it leads to the recipient contract account running its code
		2) A message is either
			1) Triggered by a transaction to another EOA or contract account
			2) Triggered internally within the EVM by a contract account when it executes the CALL family of opcodes
			   and leads to the recipient contract account running its code or value transfer to the recipient EOA
44
	TXs are grouped together into blocks
	A blockchain contains a series of such blocks that are chained together
45
	Blocks are batches of transactions with a hash of the previous block in the chain
	This links blocks together (in a chain) because hashes are cryptographically derived from the block data
	This prevents fraud, because one change in any block in history would invalidate all the following blocks
		This would happen since all subsequent hashes after the modified block would have new hashes and everyone would notice
	To preserve TX history, blocks are strictly ordered (every new block contains refernce to parent block)
	TXs within blocks are strictly ordered as well
46
	Ethereum node
		A software application that implements the Ethereum specification and communicates over the P2P network with other 
		  ethereum nodes
	Ethereum client
		A specific implementation of ethereum node
		Two most common implementation are Geth and OpenEthereum
		Ethereum TXs are sent to ethereum nodes to be broadcast across the P2P network
47
	Miners are entities running Ethereum nodes that validate and execute these TXs and combine them into blocks
	The process of validating each block by having a miner private mathematical proof is known as 'proof-of-work'
	Miners are rewarded for blocks accepted into the blockchain with a block reward in ether (currently 2 ETH)
	A miner also gets fees which is the ether spent on gas by all the TXs included in the block
48
	Block gas limit is set by miners and refers to the cap on the total amount of gas expended by all TXs in the block
	This ensures that blocks can't be arbitrarily large
	Blocks therefore are not a fixed side in terms of the number of TXs because different TXs consume different amounts of gas
49
	Blocks take time to propagate through the network and muliple miners are simultaneously producing valid blocks
	This leads to the blockchain considering multiple blocks at the same level but ultimately choosing only one at any level
	The one block that is chosen creates the canonical blockchain
	This choice is dictated by Ethereum's Greedy Heaviest Observed Subtree (GHOST) protocol
	This include stale blocks up to seves leves in the calculation of the longest chain
	Stale blocks are called uncles or ommers
50
	Consensus
		Decentalized consensus in the contex of Ethereum refers to the process of determining which miner's block should
		  be appende next to the blockchain
		This involved two key components of POW and the longest chain rule
		Miners apply thees rules to build the canonical blockchain
		This is referred to as the 'Nakamoto Consensus' and is adapted from Bitcoin
51
	State is a mapping between addresses and account states implemented as a modified Merkle Patricia trie
	A Merkle tree or trie is a type of binary tree composed of a set of nodes with
		1) Leaf nodes at the bottom of the tree that contain the underlying data
		2) Intermediate nodes where each node is the hash of its two child nodes
		3) A single root node formed from the hash of its two child nodes representing the top of the tree
52
	Ethereums POW algorithm is called 'Ethash' (previously known as Dagger-Hashimoto)
		1) The alrogithm is formally defined as `m = Hm ∧ n <= 2**256/Hd with (m, n) = PoW(Hn, Hn, d)`
		   Where...
		     Hn is the nonce of the header
		     d is a large data set needed to compute the mixHash
		     Hd is the new block's difficulty value
		   NOTE: the ∧ is the truth functional operator of logical conjunction
		         The set of operands in true iff all its operands are true
		         Basically 'and' from FCS
		2) POW is the proof-of-work function which evaluates to an array with the first item being the mixHash
		     and the second item being a pseudorandom number cryptographically dependent on `H` and `d`
53
	Blocks contain block header, TXs and ommers' block headers
	Block header contains
		1) parentHash:
			The Keccak 256-bit hash of the parent's block's header in its entirety
		2) ommersHash:
			The Keccak 256-bit hash of the ommers list portoin of this block
		3) beneficialy: 
			The 160-bit address to which all fees collected from the successful mining of this block be transferred
		4) stateRoot: 
			The Keccak 256-bit hash of the root node of the state trie, after all TXs are executed and finalizations applied
		5) transactionsRoot:
			The Keccak 256-bit hash of the root node of the trie structure populated with each TX in the TXs list portion
			of the block
		6) receiptsRoot:
			The Keccak 256-bit hash of the root node of the true structure populated with reciepts of each TX in the TXs
			list portion of the block
		7) logsBloom:
			The bloom filter composed from indexable information (logger address and log topics) contained in each log 
			entry from the receipt of each TX in the TXs list
		8) difficulty:
			A scalar value corresponding to the difficulty level of this block. This can be calculated from the previous 
			block's difficulty level and the timestamp
		9) number:
			A scalar value equal to the number of ancestor blocks. The genesis block has a number of zero
		   	NOTE: A genesis block is the first block or origin block (applies to mainnet and private networks)
		10) gasLimit:
			A scalar value equal to the current limit of gas expenditure per block
		11) gasUsed:
			A scalar value equal to the total gas used in TXs in this block
		12) timestamp:
			A scalar value equal to the reasonable outof of Unix's time() at this blocks inception
		13) extraData:
			An arbitrary btye array containing data relevant to this block
		   	This must my 32 bytes or fewer
		14) mixHash:
			A 256-bit hash which, combined with the nonce, proves that a sufficient amount of computation has been carried 
			out on this block
		15) nonce: 
			A 64-bit value which, combined with the mixhash, proves that a sufficient amount of computation has been 
			carriendo ut on this block
54
	stateRoot, transactionsRoot, and receiptsRoot are 256-bit hashes of the root nodes of modified Merkle-Patricia trees
	The leaves of stateRoot and key-value pairs of all ethereum address-account pairs, whece each respective account consists of
		1) nonce
			A scalar value equal to the number of TXs sent from this address 
			OR
			In the case of an account with associated code, the number of contract-creations made by this account
		2) balance
			A scalar value equal to the number of wei onwer by this address
		3) storageRoot
			A 256-bit hash of the root node of a modified Merkle-Patricia tree that encodes the storage contents of the
			  account (a mapping bteween 256-bit integer values) encoded into the trie as a mapping from the Keccak 256-bit
			  hash of the 256-bit integer keys to the RLP-encoded 256-bit integer values
		4) codeHash
			The hash of the EVM code of this account
			This is the code that gets executed should this address recieve a message call
			It is immutable and thus, unlike all other fields, cannot be changes after construction
55
	TX reciept is a tuple of four items comprising
		1) The cumulative gas used in the block containing the TX reciept as of immediately after the TX has happened
		2) The set of logs created through execution of the TX
		3) The bloom filter composed from information in those logs
		4) The status code of the TX
56
	Gas refund and beneficiary
		Any unused gas in a TX (gasLimit minus gas used by TX) is refunded to the sender's account at the same gasPrice
		Ether used to purchase gas used for the TX is credited to the beneficiary address (specified in the block hearder)
		The beneficiary is typically an address of an account under control of the miner
		This is the TX 'fees' paid to the miner
57
	EVM is quasi Turing complete machine where the quasi qualification comes from the fact that the computation is intrinsically
	  bounded through a parameter, gas, which limits the total amount of computation done
	ENM is the rutnime environment for smart contracts
58
	The code in Ethereum contracts is written in low-level, stack based bytecode language, referred to as the 
	  'Ethereum Virtual Machine' or 'EVM code'
	The code consists of a secries of bytes (hence called bytecode) where each byte represents an operation
59
	The EVM is a simple stack-based architecture consisting of the stack, volatile memory, non-volatile storage with a word size
	  of 256-bit (chosen to facilitate the Keccak256 hash scheme and elliptic-curve compuitations) and Calldata
60
	Stack is made up of 1024 256-bit elements
	EVM instructions can operate with the top 16 stack elements
	Most EVM instructions operate with the stack (stack-based architecture)
	There are also stack-specifice operation (eg: PUSH, POP, SWAP, DUP etc)
61
	Memory is a linear byte-array addressable at a byte-level and is volatile
	All locations are well-defined initially as zero
	This is accessed with MLOAD, MSTORE and MSTORE8 instructions
62
	Storage is a 256-bit to 256-bit key-value store
	Unlike memory, which is volatile, storage in non-volatile and is maintained as part of the system state
	All locations are well-defined initially as zero
	This is accessed with SLOAD and SSTORE instructions
63
	Calldata is a read-only byte-addressable space where the data parameter of a transaction or call is held
	This is accessed with CALLDATASIZE, CALLDATALOAD, CALLDATACOPY instructions
64
	EVM does not follow the standard von Neumann arcitechure
	Rather than storing program code in generally accessible memory or storage, it is stored separately in a virtual ROM 
	  accessibly only through a specialized instruction
65
	EVM uses big-endian ordering where the most significant byte of a word is stored at the smallest memory address and the 		  least significant byte at the largest
66
	EVM instruction can be classified into 11 categories
		1) Stop and Arithmetic operations
		2) Comparison & Bitwise Logic operations
		3) SHA3
		4) Environmental information
		5) Block information
		6) Stack, Memory, Storage and Flow operations
		7) Push operations
		8) Duplitation operations
		9) Exchange operations
		10) Logging operations
		11) System operations
67
	Stop and Arithmetic operations
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items places, Description)
	1)
		0x00, STOP, 0, 0, Halts execution
	2)
		0x01, ADD, 2, 1, Addition operation
	3)
		0x02, MUL, 2, 1, Multiplication operation
	5)
		0x03, SUB, 2, 1, Subtraction operation
	5)
		0x04, DIV, 2, 1, Integer division operation
	6)
		0x05, SDIV, 2, 1, Signed integer division operation (truncated)
	7)
		0x06, MOD, 2, 1, Modulo remainder operation
	8)
		0x07, SMOD, 2, 1, Signed modulo remainder operation
	9)
		0x08, ADDMOD 3, 1, Modulo addition operation
		NOTE: (A + B) mod C
	10)
		0x09, MULMOD, 3, 1, Modulo multiplication operation
		NODE: (A * B) mod C
	11)
		0x0a, EXP, 2, 1, Exponential operation
	12)
		0x0b, SIGNEXTEND, 2, 1, Extend length of two's complement signed integer

68
	Comparised & Bitwise Login operations
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0x10, LT, 2, 1, Less-than comparison
	2)
		0x20, GT, 2, 1, Greater-than comparison
	3)
		0x12, SLT, 2, 1, Signed less-than comparison
	4)
		0x13, SGT, 2, 1, Signed greater-than comparison
	5)
		0x14, EQ, 2, 1, Equality comparison
	6)
		0x15, ISZERO, 1, 1, Simple not operator
	7)
		0x16, AND, 2, 1, Bitwise AND operation
	8)
		0x17, OR, 2, 1, Bitwise OR operation
	9)
		0x18, XOR, 2, 1, Bitwise XOR operation
	10)
		0x19, NOT, 1, 1, Bitwise NOT operation
	11)
		0x1a, BYTE, 2, 1, Retrieve single byte from word
	12)
		0x1b, SHL, 2, 1, Left shift operation
		NOTE: For shift, the new space created is filled with a 0
	13)
		0x1c, SHR, 2, 1, Logical right shift operation
		NOTE: For shift, the new space created is filled with a 0
	14)
		0x1d, SAR, 2, 1, Arithmetic (signed) right shift operation
		NOTE: For shift, the new space created is filled with a 0

69
	SHA3	
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0x20, SHA3, 2, 1, Compute Keccak-256 hash
70
	Environmental Information
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0x30, ADDRESS, 0, 1, Get address of currenly executing contract
	2)
		0x31, BALANCE, 1, 1, Get balance of the given account
	3)
		0x32, ORIGIN, 0, 1, Get execution origination address
	4)
		0x33, CALLER, 0, 1, Get caller address
	5)
		0x34 CALLVALUE, 0, 1, Get deposited value by the instruction/transaction responsible for this exeuction
	6)
		0x35, CALLDATALOAD, 1, 1, Get input data of current environtment
	7)
		0x36, CALLDATASIZE, 0, 1, Get size of input data in current environment
	8)
		0x37, CALLDATACOPY, 3, 0, Copy input data in current environment to memory
	9)
		0x38, CODESIZE, 0, 1, Get side of code running in current environment
	10)
		0x39, CODECOPY, 3, 0, Copy code running in current environment to memory
	11)
		0x3a, GASPRICE, 0, 1, Get price of gas in current environment
	12)
		0x3b, EXTCODESIDE 1, 1, Get size of an account's code
	13)
		0x3c EXTCODECOPY, 4, 0, Copy an account's code to memory
	14)
		0x3d, RETURNDATASIZE, 0, 1, Get size of output data from the previous call from the current environment
	15)
		0x3e, RETURNDATACOPY, 3, 0, Copy output data from previous call to memory 
	16)
		0x3f, EXTCODEHASH, 1, 1, Get hash of an account's code
71
	Block information
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0x40, BLOCKHASH, 1, 1, Get the hash of one of the 2156 most recent complete blocks
	2)
		0x41, COINBASE, 0, 1, Get the blocks beneficiary address
	3)
		0x42, TIMESTAMP, 0, 1, Get the block's timestamp
	4)
		0x43, NUMBER, 0, 1, Get the block's number
	5)
		0x44, DIFFICULTY, 0, 1, Get the block's difficulty
	6)
		0x45, GASLIMIT, 0, 1, Get the block's gas limit
72
	Stack, Memory, Storage and Flow operations
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0x50, POP, 1, 0, Remove item from stack
	2)
		0x51, MLOAD, 1, 1, Load word from memory
	3)
		0x52, MSTORE, 2, 0, Save word to memory
	4)
		0x53, MSTORE8, 2, 0, Save byte to memory
	5)
		0x54, SLOAD, 1, 1, Load word from storage
	6)
		0x55, SSTORE, 2, 0, Save word to storage
	7)
		0x56, JUMP, 1, 0, Alter the program counter
	8)
		0x57, JUMPI, 2, 0, Conditionally alter the program counter
	9)
		0x58, PC, 0, 1, Get the value of the progam counter prior to the increment corresponding to this insturction
	10)
		0x59, MSIZE, 0, 1, Get the size of active memory in bytes
	11)
		0x5a, GAS, 0, 1, Get the amount of available gas, including the corresponding reduction for the cost of this TX
	12)
		0x5b, JUMPDEST, 0, 0, Mark a valid destiration for jumps. 
		This operation has no effect on machine state during execution
73
	Push operations
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0x60, PUSH1, 0, 1, Place 1-byte item on the stack
	2)
		0x61, PUSH2, 0, 1, Place 2-byte item on the stack
		
	3)
		Instructions 0x61 - 0x7e represent PUSH2 - PUSH31
			EG: PUSH31 -> 0x7e
			    PUSH14 -> 0x6d
	4)
		0x7f, PUSH32, 0, 1, Place 32-byte (full word) item on stack
74
	Duplication operations
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0x80 DUP1, 1, 2, Duplicate 1st stack item
	2)
		Instructions 0x81 - 0x8e represent DUP2 - DUP15
	3)
		0x8f, DUP16, 16, 17, Duplacate 16th stack item
75
	Exchange operations
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0x90, SWAP1, 2, 2, Exchange 1st and 2nd stack items
	2)
		0x91, SWAP2, 3, 3, Exchange 1st and 3rd stack items
	3)
		Instructions 0x91 - 0x9e represent SWAP2 - SWAP15
	4)
		0x9f, SWAP16, 17, 17, Exchange 1st and 17th stack items
76
	Logging operations
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0xa0, LOG0, 2, 0, Append log record with no topics
	2)
		0xa1, LOG1, 3, 0, Append log record with one topic
	3)
		0xa2, LOG2, 4, 0, Append log record with two topics
	4)
		0xa3, LOG3, 5, 0, Append log record with three topics
	5)
		0xa4, LOG4, 6, 0, Append log recard with four topics
77
	System operation
	The data is presented as (Opcode, Mnemonic, Stack items removed, Stack items placed, Description)
	1)
		0xf0, CREATE, 3, 1, Create a new account with associated code
	2)
		0xf1, CALL, 7, 1, Message-call into an account
	3)
		0xf2, CALLCODE, 7, 1, Message-call into an account
	4)
		0xf3, RETURN, 2, 0, Halt execution returning output data
	5)
		0xf5, DELEGATECALL, 6, 1, Message-call into this account with an alternative account's code
		   but persisting the current values for the sender and value
	6)
		0xf5, CREATE2, 4, 1, Create a new account with associated code
	7)
		0xfa, STATICCALL, 6, 1, Static message-call into an account
		NOTE: Same as 0xf1 CALL but doesn't modify state
	8)
		0xfd, REVERT, 2, 0, Halt execution reverting satet changes but returning data and remaining gas
	9)
		0xfe, INVALID,∅ ,∅, Designated invalid instruction
	10)
		0xff, SELFDESTRUCT, 1, 0, Halt execution and register account for later deletion

78
	Gas costs for different instructions are different depending on their computational/storage load on the client
	Examples
		1)
			STOP, INVALID, REVERT are 0 gas
		2)
			Most arithmetic, logic and stack operations are 3-5 gas
		3)
			CALL*, BALANCE, AND EXT* are 2600 gas
		4)
			MLOAD/MSTORE/MSTORE8 are 3 gas
		5)
			SLOAD is 2100 gas and SSTORE is 20000 gas to set a storage slot from 0 to non-0 and 5000 gas otherwise
		6)
			CREATE is 32000 gas and SELFDESTRUCT is 5000 gas
79
	A TX reverts for different exceptional conditions such as running out of gas, invalid instructions etc
	In which case all state changes made so fare are discarded and the original state of the account is restored as it was before		  this TX executed
80
	A TX with a contract address destination has the contract's function target and the required arguments in the data field of 
	  the TXs in the data field of the TX
	These are encoded according to the Application Binary Interface (ABI)
81
	Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from
	  outside the blockchain and for contract-to-contract interaction
	1)
		Interface functions of a contract are strongly typed, known at compilation time and static
	3)
		Contracts will have the interface definitions of any contracts they call available at compile time
82
	Function selector is the first four bytes of the call data for a function call and it specifier the function to be called
	1)
		It is the first (lef, high-order in big-endian) four bytes of the Keccak-256 hash of the signature of the function
	2)
		The signature is defined as the canonical expression of the basic prototype without data location specifier
		IE: The function name with the parenthesised list of parameter types
		    Parameter types are split by a single comma, no spaces are used
	3)
		Function arguments
		The encoded arguments follow the function selector from the fifth byte onwards
83
	Block explorers are portals that allow anyone to see real-time data on blocks, transactions, accounts, contract interactions etc
	A popular ethereum block explorer is etherscan.io
84
	Mainnet (short for 'main network') is the main public ethereum blockchain. There are other Ethereum 'testnets' where protocol
	  or smart contract developers test their protocol upgrades or contracts
	While mainnet uses real ETH, testnets use test ETH that can be obtained from faucets
	The popular testnets are
		Görli
			A proof-of-authority (a small number of nodes are allowed to validate TXs and create blocks)
			This works across clients
		Kovan
			A proof-of-authority testnet for those runnnig OpenEthereum clients
		Rinkeby
			A proof-of-authority testnet for those running Geth client
		Ropsten
			A proof-of-work testnet
			This means that it's the best representation of mainnet ethereum
85
	Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications,
	  client APIs, and contract standards.
	Standards Track EIPs are separated into a number of types
		1) Core
			Improvement requiritng a consensus fork as well as changes that are not necessarily consensus criticial but
			  may be revelant to 'core dev' discussions
		2) Networking
			Includes improvements around devp2p and Light Ethereum Subprotocol, as well as proposed improvements to 
			  network protocol specifications of whisper and swarm
		3) Interface
			Includes improvements around client API/RPC specifications and standards
			Also certoin language-level standards like method names and contract ABIs
			The label 'interface' aligns with the intefraces repo and discussions should primarity occur in that	
			  repository before an EIP is submitted to the EIP repository
		4) ERC
			Application-level standards and conventions, including contract standards such as token standards (ERC-20), 
			  name registries, URI scemes, library/package formats, and wallet formats
		5) Meta
			Describes a process succounding Ethereum or proposes a change to (or an event in) a process
		6) Informational
			Describes a ethereum design issue, or provides general guidelines or information to the ethereum community,
			  but does not propose a new feature
86
	Eth2 or Ethereum 2.0 refers to a set of interconnected upgrades that will make Ethereum more scalable, more secur, and more 
	  sustainable
87
	Immutable code
		Once a contract's code is deployed, it becomes immutable (with expections noted below)
		Standard software development practices that rely on being able to fix bugs and add new features to deployed code 
		  do not apply here.
		This represents a significant security challenge for smart contract development
		There are three exceptions
			1)
				The modified contract can be deployed at a new address (and old state carried over) but all interacting
			 	  entities should be notified/enabled to interact with the updated contract at the new address
				This is typically considered impractical
			2)
				The modified contract can be deployed as a new implementation in a proxy pattern where the proxy points
				  to the modified contract after the update
				This is the most commonly used approach to update/add functionality
			3)
				CREATE2 opcade allows updating in place using init_code
88
	Web3 is a permissionless, trust minimized and censorship-resistant network for transfer of value and information
	1)
		The popular appreach to realize web3 is to build it over a foundation of p2p network of nodes for
			compute
			communication
			storage
	2)
		In the ethereum ecosystem, this is a combination of the ethereum blockchain, waku (previously whisper) and swarm
		  respectively
	3)
		Privacy and anonymity are big motivating factors in web3
	4)
		Most of the foundational security design principles and development practives from web3 still apply to web3, but 
		  web3 security is indeed a paradigm shift along many frontiers
89
	Languages
		Web3 programming languages such as Javascript, Go, Rust and Nim and used extensively in Web3
		but the entire domain of smart contracts is new and specific to web3
		Languages such as solididy and vyper were created exclusivery for web3
90
	On-chain vs off chain	
		Smart contracts are 'on-chain' web3 components and they interact with 'off-chain' components that are very similar
		  to web2 software
		So the major difference in security perspectives beteewn web3 and web2 mostlsy narrow down to security considerations
		  of smart contracts vis-a-vis web2 software
91
	Open source and transparets
		Given the emphasis or trust-minimization, web3 software (especially smart contracts) and expected to be open source
		  by default
		1) 
			The deployed bytecode is also expected to be source-code verified (on a service such as etherscan)
			Security by obscurity with proprietary code is not part of web3's ethos
		2)
			All interactions with smart contracts are recorded on the blockchain as TXs
			This includes the TX's senders, data and outcome
			Having complete visibily into the entire history of TXs and state transitions is akin to having a publicly
			  accessible audit log of a system since inception
		3)
			Furthermore, TXs that are still 'in flight' and are yet to be confirmed on the blockchain are also publicly 
			  visible in pending TX queues (IE: mempools)
			This opens the opportunity for frontrunning attacks
92
	Unstoppable and immutable
		Web3 applicatnios, popularly known as decentralized applications 'ÐApps' are expected to be unstoppable and immutable
		  because they can run on a decentralized blockchain network
		1)
			There should not be any one entity that can unilaterally decide to stop a running ÐApp or make changes to it
			TXs and data on the blockchain are guaranteed to be immutable unless a majority of the network decides otherwise
		2)
			Smart contract, in general, are expected (by users) to not have kill switched controlled by deployers
			They are also expected to not be arbitrarily upgradeable
			Both stem from the web3 goal of trust-minimization (IE: lack of need to turst potentially malicious ÐApp devs)
			However, this makes fixng security vulnerabilities in deployed code and responding to exploits
			  very challenging
93
	Pseudononymous teams and DAOs
		Perhaps inspired by Bitcoin's Satosh Nakamotoo, there is a trend among some project teams in Web3 to be 
		  speuononymous and known only by their online handles
		1)
			One reason for this could be to avoid potential legal implications in future, given the regulatory
			  uncertianty in this plsace
			This makes it harder to associate any social reputation at is pertains to perceived security trustworthiness
			  of the product or the processes behind its development
			It also makes it tricky to hold onyone legally/socially liable or accountable
		2)
			"Trust the software not wetware" (IE: people) is the mantra here
			While this may be an extreme view, there are still social process around rollout and governance of 
			  projects which affect security posture
		3)
			To minimoze the role of influence of a few privileged invididuals in the lifecycle of projects, there is an
			  increasing trend towards governance by token-holding community members - a DAO
			DAO stands for Decentralized Autonomous Organization 
			The community members are pseudononymous token holding blockchain addresses making voting-based decisions
			  on project treasury spending and protocol changes
			While this reduces centralized points of wetware failure, it potentially slows down decision-making on 
			  security-critical aspencs and may even lead to project forks
94
	New architecture, language & toolchains
		Ethereum has a new virtual machine ENV architecture which is a stack-based machine with 256-bit words and
		  associated gas semantics
		1)
			Solidity lanugage continues to dominate smart contracts without much real competition (expect Vyper perhaps)
		2)
			The associated toolchains which include 
				Deveoplment environment (EG: Truffle, Brownie, Hardhat)
				Libraries (EG: OpenZeppelin)-
				Seccurity tools (EG: Slither, MythX, Securify)
				Wallets (EG: Metamask)
			  are maturing but still playing catchup to the exponential growth of the space
95
	Byzantine Threat Model
		The web3 threat model is based on byzantine faults dealing with arbitrary malicious behaviour and governed by 
		  mechanism design
		1)
			Given the aspirational absecnec of trusted intermediaries, everyone and everything is meant to be untrusted
			  by default
			Participants in this model include developers, miners/validators, infrastructure providers and users, all of
			  whom could potentiall be adversaries
		2)
			This is fundamentally different threat model from that of web2 where there are generalized notions of trusted
			  insiders with authorized access to resources/assets that have to be protected against untrusted outsiders 
			  (and malicious insiders)
			Web3 is the ultimate zero trust scerario
96
	Keys & tokens
		While 'crypto' amy indede mean cryptocurrenties to some non-technical observers, it factually refers to cryptography
		  which is a fundamental bedrock on web3
		As much as we unknowingly use cryptography in the web2 world, web3 is taking it to the masses
		Cryptographing keys are first-class members of the web3 world
	1)
		Without the presence of web3 trusted intermediaries who can otherwise reset passowords or restore accounts/assets from
		  their centralized databases, web3 ideologically pushes the onus of managing keys (and the assets they control)
		  to end users in their wallets
		Loss of private keys (or seed phrases) is irreversible and many assets have been lost to such incidents
		This is a significant mindset shift from the web2 world wheer passwords have become far too common, security pundits			  
		are tired of bemoaning to the use of commonly reused simple passwords, password technologies continue to evade us
		Web2 passowrds here symbolize the role of trusted centralized intermediaries that web3 is seeking to replace
	2)
		Web2 security breaches targeting financial assets (IE: Excluding ransomware and botnets for DDOS) typically involve
		  stealing of financial or personal data which is then solf on the dark web and used for monetary gain
		This is getting much harder because of various checks and measures (both technical and regulatory) being put in place
		  (at centralized intermediaries) to reduce such cybersecurity incidents and prevent anomalous asset transfers
		When such unauthorised asset transfers do happen the involved intermediaries may even cooperate to reverse such TXs
		  and make good
	3)
		The notion of assets in Web3 is fundamentally different
		Cryptoassets are border digital tokens whose accounting ledger is managed by consensus on the blockchain and ownership
		  is determined by access to corresponding cryptographic keys
		If someone gets access to your private keys controlling cryptoassets, they can transfer those assets to blockchain 
		  addresses controlled by their keys
		In a perfectly decentralized words, no intermedialy (EG: centralized exchange) should exist that can reverse such 
		  a loss - TXs are immutable
		Because there are limited response options, preventive security measures become more critical in the web3 space
97
	Composability by design
	Permissionless innovation and censhorship-resistance are core aspirational goals of web3
	1)
		There are numerous stories of web2 companies that initiall enticed developer to build on their platforms only to 
		  shut them out later when they were perceived as a competitive threat
	2)
		Web3 applications, especially smart contract, are open by design and can be accessed permissionlessly by end users
		  and other smart contract alike
	3)
		This composability lends itself to applications that can be layered on top of others like legos, which is great if
		  everything holds up and new loga toys are reliably built on therns
		However, this unconstrained composability introduces unexpected cross-systemic dependencies that may trigger invalid
		  assumptions across components (likely built by different teams with different constraints in mind)
		This may lead to attack surfaces being exposed that were previously unconsidered
	4)
		This makes characterizing web3 vulnerabilies and exploit sceranies very challenging without deep knowledge of all 
		  interacting components, constraints and configurations
98
	Compressed timescales
	It feels like innovation in the web3 space moves at warp speed
	Aspecds of transparent-development and composability-by-design are strong catalysts to acceletaring permissionless and 
	  borderless participation which is further incentivized by internet-native cryptoeconomic tokens - a perfect storm
	1)
		This shirnks the innovation timescales by orders of magnitude where new waves of experiments happen over weeks or 
		  months instead of the years it typically takes within the walled gardens of web2
		It may seems like the only moat here is the speed of execution
	2)
		This compressed timescale has a tangible impact on security considerations during design, development and deployment
		Corners are cut and shortcuts taken to ride new waves of hype
		The end result is a poorly tested system that holds millions of dollars worth of tokens but is vulnerable to exploits
99
	Test-in-prod
	A combination of compressed timescale, unrestricted composability, byzantine threat model and challenges of replicating full 
	  state for predicting failure modes of interacting components built with rapidly evolving experimental software/tools in 
	  many ways forces realistic testing to happen only in production (IE: on the 'mainnet')
	This implies that complex technical and cryptoeconomic exploits may only be discoverably upon production deployment
100
	Audit-as-a-silver-bullet
	Secure Software Development Lifecycle (SSDLC) processes for web2 products have evolved over several decades to a point where
	  they are expected to meet some minimum requirements of a combination of internal validation, external assessments 
	  (EG: product/process audits, penetration testing) and certifications depending on
		Value of managed assets
		Anticipated risk
		Whreat model
		Market domain of products (eg: financial sector has stricted regulatory compliance requirements)
101
	Web3 projects seem to increasingly rely on external audits as a stamp of security approval
	This is typically justified by the lack of sufficient in-house security expertise
	While the optics of this approach seems to falsely convince speculators, this approach is untenable for several reasonss
	1)
		Audits are currently very expensive because demand is much greater than supply for top-rated audit teams that have
		  the experience and reputation to analyze complex projects
	2)
		Audits are typically commissined once at the end of the project development just before production release
	3)
		Upgrades to projects go unaudited for commercial or logistical reasons
	4)
		The expectation (from the project team and users) is that audits are a panacea for all vulnerabilities and that the
		  project is 'bug-free' after a short audit (typically a few weeks)
