1
	Audit
	An external security assessment of a project codebase
	Typically requested and paid-for by the project team
	1
		It detects and describes (in a report) security issues with underlying vulnerabilities, severity/difficulty, potential
		  exploit scenarios and recommended fixes
	2
		It also provides subjective insights into code quality, documentation and testing
	3
		The scope/depth/format of audit varies across auditing teams but they generally cover similar aspects
2
	Audit scope
	For Ethereum-based smart-contract projects, the scope is typically the on-chain smart contract code and sometimes includes the
	  off-chain components that interact with the smart contracts
3
	Audit goal
	The goal of audits is to assess project code (with any associated specification, documentation) and alert project team, 
	  typically before launch, of potential security-related issues that need to be addressed to improve security posture, decrease
	  attack surface and mitigate risk
4
	Audit Non-goal
	Audit is not a security guarantee of 'bug-free' code by any stretch of the imagination but a best-effort endeavour by trained
	  security experts operating within a reasonable constaints of time, understanding, expertise and of course, decidability
5
	Audit target
	Security companies execute audits for clients who pay for their services
	Engagements are therefore geared towards priorities of project owners and not project users/investors
	Audits are not intended to alert potential projects users of any inherent risk
	That is not their business/technical goal
6
	Audit need
	Smart contract based projects do not have sufficient in-house Ethereum smart contract security expertise and/or time to perform
	  internal security assessments and therefore rely on external experts who have domain expertise in those areas
	Even if projects have some expertise in-house, they would still benefit from an unbiased external team with 
	  supplementary/complementary skill sets that can review the assumptions, design, specification and implemenation of the
	  project codebase
7
	Audit types
	Depend on the scope/nature/status of projects but generally fall into the following categories
		1) New audit
			For a new project that is being launched
		2) Repeat audit
			For a new version of an existing project being revised with new/fixed features
		3) Fix audit
			For reviewing the fixes made to the findings from a current/prior audit
		4) Retainer audit
			For constantly reviewing project updates
		5) Incident audit
			For reviewing an exploit incidentt, root causing the incident, identifying the underlying vulnerabilities and
			  proposing fixes
8
	Audit timeline
	Depends on the scope/nature/status of the project to be assessed and the type of audit
	This may vary from a few days for a fix/retainer audit to several weeks for a new/repeart/incident audit
9
	Audit effort
	Typically involves more than one auditor simultaneously for getting independent, redundant or supplementary/complementary
	  assessment expertise on the project
10
	Audit costs
	Depends on the type/scope of audit but typically costs upwards of USD 10K/week depending on the complexity of the project, 
	  market demand/supply for audits and the strength/reputation of the auditing firm
11
	Audit prerequisites should include
	1
		Clear definition of the scope of the project to be assessed typically in the form of a specific commit hash of
		  project files/folders on a GitHub repository
	2
		Public/private repository
	3
		Public/anonymous team
	4
		Specification of the project's design and architecture
	5
		Documentation of the project's implementation and business logic
	6
		Threat models and specific areas of concern
	7
		Prior testing, tools used, other audits
	8
		Timeline, effort and costs/payments
	9
		Engagement dynamics/channels for questions/clarifications, findings communication and reports
	10
		Points of contact of both sides
12
	Audit limitations
	Audits are necessary (for now at least) but not sufficient
	1
		There is risk reduction but residual risk exists because of several factors such as... 
			Limited amount of audit time/effort
		  	Limited insights into project specification/implementation
			Limited security expertise in the new and fast evolving technologies
			Limited audit scope
			Significant project complexity
			Limitations of automated/manual analysis
	2
		Not all audits are equal
		It is greatly dependent on the expertise/experience of auditors, effort invested vis-a-vis project complexity/quality
		  and tools/processes used
	3
		Audits provide a project's security snapshot over a brief (typically few weeks) period
		However, smart contracts need to evolve over time to add new features, fix bugs or optimize
		Relying on external audits after every change is impractical
13
	Audit reports
	Include details of the...
		Scope
		Goals
		Effort
		Timeline
		Approach
		Tools/techniques used
		Findings summary
		Vulnerability details
		Vulnerability classification
		Vulnerability severity/difficulty/likelihood
		Vulnerability exploit scenarios
		Vulnerability fixes
		Informational recommendations/suggestions on programming best practices
14
	Audit Findings Classification
	The vulns found during the audit are typically classified into different categories which helps to understand the...
		Nature of the vuln
		Potential impact/severity
		Impacted project components/functionality
		Exploit scenarios
	EG trail of bits uses the following classification
	1
		Access controls
		Related to authorization of users and assessment of right
	2
		Auditing and logging
		Related to auditing actions or logging of problems
	3
		Authentication
		Related to the identification of users
	4
		Configuration
		Related to security configurations of servers, devices of software
	5
		Cryptography
		Related to protecting the privacy or integrity of data
	6
		Data exposure
		Related to unintended exposure of sensitive information
	7
		Data validation
		Related to improper reliance on the structure or values of data
	8
		Denial of service
		Related to causing system failure
	9
		Error reporting
		Related to the reporting of error conditions in a secure fashion
	10
		Patching
		Related to keeping software up to date
	11
		Session management
		Related to the identification of authenticated users
	12
		Timing
		Related to race conditions, locking or order of operations
	13
		Undefined behaviour
		Related to undefined behaviour triggered by the program
15
	Audit findings likelihood/difficulty
	Per OWASP, likelihood or difficulty is a rough measure of how likely or difficult this particular vulnerability is to be 
	  uncovered and exploited by an attacker
	OWASP proposes three Likelihood levels of
		Low
		Medium
		High
	EG trail of bits classifies every finding into four difficulty
		1) Undetermined
			The difficulty of exploit was not determined during this engagement
		2) Low
			Commonly exploited, public tools exist or can be scripted that exploit this flaw
		3) Medium
			Attackers must write an exploit, or need an in-depth knowledge of a complex system
		4) High
			The attacker must have privileged insider access to the system, may need to know exteremely complex technical 
			  details or must discover other weaknesses in order to exploit this issue
16
	Audit findings impact
	Per OWASP, this estimates the magnitude of the techincal and business impact on the system if the vulnerability were to be
	  exploited
	OWASP proposes three impact levels of low, medium and high
17
	Audit findings severity
	Per OWASP, the likelihood estimate and the impact estimate are put together to calculate an overall severity for this risk
	This is done by figuring out whether the likelihood is low, medium or high and then do the same for impact
	1
		OWASP proposes a 3x3 severity matrix which combines the three likelihood levels with the three impact levels
	2
		Severity matrix
		(imagine the following as a 3x3 matrix)
		(likelihood & impact = SEVERITY)
		--------------------------------------------------------------------------------------
		low & low = NOTE		medium & low = LOW		high & low = MEDIUM
		low & medium = LOW		medium & medium = MEDIUM	high & medium = HIGH
		low & high = MEDIUM		medium & high = HIGH		high & high = CRITICAL
		--------------------------------------------------------------------------------------
	3
		Trail of bits uses
		1) Informational
			The issue does not pose an immediate risk, but is relevant to security best practices or Defense in Depth
		2) Undetermined
			The extent of the risk was not determined during this engagement
		3) Low
			The risk is relatively small or is not a risk the customer has indicated is important
		4) Medium
			Individual user's information is at risk, expoitation would be bad for client's reputation, moderate financial
			  impact, possible legal implications for the client
		5) High
			Large numbers of users, very bad for client's reputation, moderate financial impact, possible legal implications
			  for client
	4
		ConsenSys uses
		1) Minor
			Issues are subjective in nature
			They are tpyically suggestions around best practices or readability
			Code maintainers should use their own judgement as to whether to address such issues
		2) Medium
			Issues are objective in nature but are not security vulnerabilities
			These should be addressed unless there is a clear reason not to
		3) Major
			Issues are security vulnerabilities that may not be directly expoitable or may require certain conditions in
			  order to be exploited
			All major issues should be addressed
		4) Critical
			Issues are directly exploitable security vulnerabilities that need to be fixed
18
	Audit checklist for projects (see https://blog.trailofbits.com/2018/04/06/how-to-prepare-for-a-security-audit) for
	  'Trail of Bits' (ToB) recommendations
		1) Resolve the easy issues
			1) Enable and address every last compiler warning
			2) Increase unit and feature test coverage
			3) Remove dead code, stale branches, unused libraries and other extraneous weight
		2) Document
			1) Describe...
				What you product does
				Who uses it
				Why they use it
				How it delivers
			2) Add comments about intended behaviour in-line with the code
			3) Label and describe your tests and results, both positive and negative
			4) Include past reviews and bugs
		3) Deliver the code batteries included (??? what is code battery ???)
			1) Document the steps to create a build environment from scratch on a computer that is fully disconnected from
			  your intenal network
			2) Include external dependencies
			3) Document the build process, including debugging and the test environment
			4) Document the deployment process and environment, including all the specific versions of external tools and 
			  libraries for this process
19
	Audit techniques
	Involve a combination of different methods that are applied to the project codebase with accompanying specification and 
	  documentation
	Many are automated analyses performed with tools and some require manual assistance
		1
			Specification analysis (manual)
		2
			Documentation analysis (manual)
		3
			Testing (automated)
		4
			Static analysis (automated)
		5
			Fuzzing (automated)
		6
			Symbolic checking (automated)
		7
			Formal verification (automated)
		8
			Manual analysis (manual)
	One may think of these as manual/semi-automated/fully-automated, where the discinction between semi-automated and 
	  fully-automated is the difference between a tool that requires a user to define properties vs. a tool that requires (almost)
	  to user configuration except to triage results
	Fully-automated tools tend to be straightforward to use, while semi-automated tools require some human assistantce and 
	  therefore are more resource-expensive
20
	Specification analysis
	Specification describes in detail what (and sometimes why) the project and its various components are supposed to do 
	  functionally as part of their design and architecture
	1
		From a security perspective, it specifies what the assets are, where they are held, who are the actors, priviliges of
		  actors, who is allowed to access what and when, trust relationships, threat model, potential attack vectors, 
		  scenarios and mitigations
	2
		Analysing the specification of a project provides auditors with the above details and lets them evaluate the assumptions
		  made and may indicate any shortcomings
	3
		Very few smart contract projects have detailed specifications at their first audit stage
		At best, they have some documentation about what is implemented
		Auditors spend a lot of time inferring specification from documentation/implementation which leaves them with less time
		  for vulnerability assessment
21
	Documentation analysis
	Documentation is a description of what has been implemented based on the design and architectural requirements
	1
		Documentation answers 'how' something has been designed/achitected/implemented without necessarily addressing the 'why'
		  and the design/requirement goals
	2
		Documentation is typically in the form of Readme files in the Github repositore describing individual contract 
		  functionality combined with functional NatSpec and individual code comments
	3
		Documentation in many cases serves as a substitute for specification and provides critical insights into the 
		  assumptions, requirements and goals of the project team
	4
		Understanding the documentation before looking at the code helps auditors save time in inferring the architecture of
		  the project, contract interactions, program constraints, asset flow, actors, threat model and risk mitigation
		  measures
	5
		Mismatches between the documentation and the code could indicate stale/poor documentation, software defects or security
		  vulnerabilities
	6
		Auditors are expected to encourage the project team to document thoroughly so that they do not need to waste their time
		  inferring this by reading code
22
	Testing
	Software testing or validation is a well-known fundamental seftware engineering primitive to determine if software produces
	  expected outputs when executed with different chosen inputs
	1
		Smart contract testisg has a similar motivation but is arguably more compilcated despite their relatively smaller sizes
		  (in LoC) compared to Web2 software
	2
		Smart contract development platforms (Truffle, Embark, Brownie, Waffle, Hardhat etc) are relatively new with different
		  levels for support for testing
	3
		Projects, in general, have very little testing done at the audit stage
		Testiing integrations and composability with mainnet contracts and state is non-trivial
	4
		Test coverage and test cases give a good indication of project maturity and also provide valuable insights to
		  auditors into assumptions/edge-cases for vulnerability assessments
	5
		Auditors should expect a high-level of testing and coverage because this is a must-have softeng discipline, especially
		  when smart contracts that are by-design exposed to everyone on the blockchain and end up holding assets worth
		  tens of millions of dollars
	6
		"Program testing can be used to show the presence of bugs, but never to show their absence!"
		  - E.W. Dijkstra
23
	Static analysis
	Is a technique of analying program properties without actually executing the program
	1
		This is in contrast to software testing where programs are actually executed/run with different inputs
	2
		For smart contracts, static analysis can be performed on the Solidity code or on the EVM bytecode
		'Slither' performs static analysis at the Solidity level while 'Mythril' analyzes EVM bytecode
	3
		Static analysis typically is a combination of control flow and data flow analyses
24
	Fuzzing
	Aka 'fuzz testing' is an automated software testing technique that involves providing invalid, unexpected, or random data as 
	  inputs to a computer program
	The program is then monitored for exceptions such as crashes, failing built-in code assertions, or potential memory leaks
	1
		Fuzzing is especially relevant to smart contracts because anyone can interact with them on the blockchain with random
		  inputs without necessarily having a valid reason or expectation (arbitrary byzantine behaviour)
	2
		'Echidna' and 'Harvey' are two popular tools for smart contract fuzzing
25
	Symbolic checking
	Is a technique of checking for program correctness
	IE proving/verifying, by using symbolic inputs to represent set of states and transitions instead of enumerating individual
	  states/transitions separately
	1
		Model checking or property checking is a method for checking whether a finite-state model of a system meets a given
		  specification (also known as correctness)
	2
		In order to solve such a problem algorithmically, both the model of the system and its specification are formulated
		  in some precise mathematical language
		To this end, the problem is formulated as a task in logic, namely to check whether a structure satisfies a given logical
		  formula
	3
		A simple model-checking problem consists of verifying whether a formula in the propositional logic is satisfied by a 
		  given structure
	4
		Instead of enumerating reachable states one at a time, the state space can sometimes be traversed more efficiently by
		  considering large numbers of states as a single step
		When such state space traversal is based on representations of a set of states and transition relations as logical
		  formulas, binary decision diagrams (BDD) or other related data structures, the model-checking method is symbolic
	5
		Model-checking tools face a combinatorial blow up of the state-space, commonly known as the state explosion problem,
		  that must be addressed to solve most real-world problems
	6
		Symbolic algorithms avoid explicitly constructing the graph for the finite state machines (FSM)
		Instead, they represent the graph implicitly using a formula in quantified propositional logic
26
	Formal verification
	Is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal
	  specification or property, using the formal methods of mathematics
	1
		Formal verification is effective at detecting complex bugs which are hard to detect manually or using simpler
		  automated tools
	2
		Formal verification needs a specification of the program being verified and techniques to translate/compare the
		  specification with the actual implementation
	3
		`Certora`'s Prover and `ChainSecurity`'s VerX are examples of formal verification tools for smart contracts
		`KEVM` from `Runtime Verification Inc` is a formal verification framework that models EVM semantics
27
	Manual analysis
	Is complimentary to automated analysis using tools and serves a critical need in smart contract audits
	1
		Automated analysis using tools is cheap (typically open-sounce free software), fast, deterministic and scalable
		  (varies depending on the tool being semi or fully automated) but however is only as good as the properties it is made
		  aware of, which is typically limited to Solidity and EVM related constaints
	2
		Manual analysis with humans, in contrast, is expensive, slow, non-deterministinc and not scalable because human 
		  expertise in smart contract security is a rare/expensive skill set ttoday and we are slower, prone to error and
		  inconsistent
	3
		Manual analysis is however the only way today to infer and evaluate business logic and application-level constaints
		  which is where a majority of the serious vulnerabilities are being found
28
	False positives
	Are findings which indicate the presence of vulnerabilities but which in fact are not vulnerabilities
	Such false positives could be due to incorrect assumptions or simplifications in analysis which do not correctly consider all
	  the factors required for the actual presence of vulnerabilities
	1
		False positives require further manual analysis on findings to investigate if they are indeed false or true positives
	2
		High number of false positives increases manual effort in verification and lowers the confidence in the accuracy of the
		  earlier automated/manual analysis
	3
		True positives might sometimes be classified as false positives which leads to vulnerabilities being exploited instead
		  of being fixed
29
	False negatives
	Are missed findings that should have indicated the presence of vulns but which are in fact not reported at all
	Such false negatives could be due to incorrect assumptions or inaccuracies in analysis which do not correctly consider the 
	  minimum factors required for actual presence of vulns
	1
		False negatives, per definition, are not reported or even realized unless a different analysis reveals their presence
		  or the vulns are exploited
	2
		High number of false negatives lowers the confidence in the effectiveness of the earlier manual/automated analysis
30
	Audit firms
	The following is a list of audit firms (popular ones but not all)
	ABDK
	Arcadia
	Beosin
	Blockchain Consilium
	BlockSec
	CertiK
	ChainSafe
	ChainSecurity
	Chainsulting
	CoinFabrik
	ConsenSys Diligence
	Dedaub
	G0
	Hacken
	Haechi
	Halborn
	HashEx
	Iosiro
	Least Authority
	MixBytes
	NCC
	NewAlchemy
	OpenZeppelin
	PeckShield
	Pessimistic
	PepperSec
	Pickle
	Quantstamp
	QuillHash
	Runtime Verification
	Sigma Prime
	SlowMist
	SmartDec
	Solidified
	Somish
	Trail of Bits
	Zokyo
31
	Smart contract security tools
	Are critical in assisting smart contract developers and auditors with showcasing (potentiall) exploitable vulnerabilities,
	  highlighting dangerous programming styles or surfacing common patterns of misuse
	None of these however replace the need for manual review/validation to evaluate contract-specific business logic and other
	  complex control-flow, data flow & value flow aspects
32
	Categories of security tools
	Tools for... 
		Testing
		Test coverage
		Linting
		Disassembling
		Visualization
		Static analysis
		Dynamic analysis
		Formal 
	  ...verification of smart contracts
33
	`Slither` is a Solidity static analysis framework written in Python3
	It runs a suite of vulnerability detectors, prints visual information about contract details, and provides an API to easily
	  write custom analyses
	Slither enables developers to find vulns, enhance their code comprehension, and quickly prototype custom analyses
	It implements 74 detectors in the publicly available free version (with trophies that showcase Slither findings in real-world
	  contracts)
	The trophies are an interesting read
		https://github.com/crytic/slither/blob/master/trophies.md
34
	Slither features
		Detects vulnerable Solidity code with low false positives
		Identifies where the error condition occurs in the source code
		Easily integrates into continuous integration and Truffle builds
		Built-in 'printers' quickly report crucial contract information
		Detector API to write custom analyses in Python
		Abilitiy to analyse contracts written in Solidity >=0.4
		Intermediate representation (SlithIR) enables simple, high-precision analyses
		Correctly parses 99.9% of all public Solidity code
		Average execution time of less than 1 second per contract
35
	Slither bugs and optimizations detection can run on a Truffle/Embark/Dapp/Etherlime/Hardhat application or an a single .sol file
	1
		Slither runs all detectors by default
		To run only selected detectors, use `--detect detector1,detector2`
		To exclude detectors, use `--exclude detector1,detector2`
	2
		To exclude detectors with an informational or low severity, use `--exclude-informationar` or `--exclude-low`
	3
		`--list-detectors` lists all available detectors
36
	Slither printers allow printing contract information with `--print` and following options
	  (with contract-summary, human-summary, inheritance-graph for quick review, and others such as call-graph, cfg, 
	  function-summary and vars-and-auth for in-depth review)
		1
			call-graph
			Expart the call-graph of the contracts to a dot file
		2
			cfg
			Export the CFG of each functions
		3
			constructor-calls
			Print the constructors executed
		4
			contract-summary
			Print a summary of the contracts
		5
			data-dependency
			Print the data dependencies of the variables
		6
			echidna
			Export Echidna guiding information
		7
			evm
			Print the evm instructions of nodes in functions
		8
			function-id
			Print the keccak256 signature of the functions
		9
			function-summary
			Print a summary of the functions
		10
			human-summary
			Print a human readable summary of the contracts
		11
			inheritance
			Print the inheritance graph of each contract to a dot file
		12
			inheritance-graph
			Export the inheritance graph of each contract to a dot file
		13
			modifiers
			Print the modifiers called by each function
		14
			require
			Print the require and assert calls of each function
		15
			slithir
			Print the slithIR representation of the functions
		16
			slithir-ssa
			Print the slithIR representation of the functions
		17
			variable-order
			Print the storage order of the state variables
		18
			vars-and-auth
			Print the state variables written and the authorization of the functions
37
	Slither upgradeabalitiy checks helps review contracts that use the delegatecall proxy pattern using 
	  `slither-check-upgradeability` tool with the following options
		1) become-constant
			Variables that should not be constant
		2) function-id-collision
			Function ids collision
		3) function-shadowing
			Functions shadowing
		4) missing-calls
			Missing calls to init functions
		5) missing-init-modifier
			initializer() is not called
		6) multiple-calls
			Init functions called multiple times
		7) order-vars-contracts
			Incorrect vars order with the v2
		8) order-vars-proxy
			Incorrect vars order with the proxy
		9) variables-initialized
			State variables with an initial value
		10) were-constant
			Variables that sholud be constant
		11) extra-vars-proxy
			Extra vars in the proxy
		12) missing-variables
			Variable missing in the v2
		13) extra-vars-v2
			Extra vars in the v2
		14) init-inherited
			Initializable not inherited
		15) init-missing
			Initializable is missing
		16) initialize-target
			Initialize function that must be called
		17) initializer-missing
			initializer() is missing
38
	Slither code similarity detector (a research oriented tool) uses state-of-the-art machine learning to detect similar (vuln)
	  Solidity functions
	1
		It uses a pre-trained model from etherscan_verified_contracts with 60,000 contracts and mare than 850,000 functions
	2
		It uses FastText, a vector embedding technique, to generate compact numerical representations of every function
	3
		It has four modes
			1) test
				Finds similar functions to your own in a dataset of contracts
			2) plot
				Provide a visual representation of similarity of multiple sampled functions
			3) train
				Builds new models of large datasets of contracts
			4) info
				Inspects the internal information of the pre-trained model or the assessed code
39
	Slither contract flattening tool `slither-flat` produces a flattened version of the codebase with the following features
	1
		Supports 3 strategies
			1) MostDerived
				Export all the most derived contracts (every file is standalone)
			2) OneFile
				Export all contracts in one standalone file
			3) LocalImport
				Export every contract in one separate file, and include import ".." in their preludes
	2
		Supports circular dependency
	3
		Supports all the compilation platforms (Truffle, embark, builder, etherlime)
40
	Slither format tool `slither-format` generates automatically patches
	The patches are compatible with git
	Patches should be carefully reviewed before applying
	Detectors supported with this tool are
		unused-state
		solc-version
		pragma
		naming-convention
		external-function
		constable-states
		constant-function
41
	Slither ERC conformance tool `slither-check-erc` checks the following for ERC's conformance for (20, 721, 777, 165, 223, 1820)
		All the functions are present
		All the events are present
		Functions return the correct type
		Functions that must be view are view
		Event's parameters are correctly indexed
		The functions emit the events
		Derived contracts do not break the conformance
42
	Slither property generation tool `slither-prop` generates code properties (EG invariants) that can be tested with unit tests or
	  Echidna, entirely automatically
	The ERC20 scenarios that can be tested are
		1) Transferable
			Test the correct tokens transfer
		2) Pausable
			Test the pausable functionality
		3) NotMintable
			Test that no one can mint tokens
		4) NotmintableNotBurnable
			Test that no one can mint or burn tokens
		5) NotBurnable
			Test that no one can burn tokens
		6) Burnable
			Test the burn of tokens
			Require the `burn(address) returns()` function
43
	Slithers new detectors
	Slither's plugin architecture lets you integrate new detectors that run from the cmdline
	The skeleton for a detector has
		1) ARGUMENT
			Lets you run the detector from the commandline
		2) HELP
			Is the information printed from the cmdline
		3) IMPACT
			Indicates the impact of the issue
			Allowed values are INFORMATIONAL | LOW | MEDIUM | HIGH
		4) CONFIDENCE
			Indicates your confidence in the analysis
			Allowed values are LOW | MEDIUM | HIGH
		5) WIKI
			Constants are used to generate automatically the documentation
		6) _detect()
			Is the function that implements the detector logic and needs to return a list of findings
44
	Manticore 
	Is a symbolic execution tool for analysis of Ethereum smart contracts (besides Linux binaries and WASM modules)
		1) Program Exploration
			Manticore can execute a program with symbolic inputs and explore all the possible states it can reach
		2) Input generation
			Manticore can automatically produce contrete inputs that result in a given program state
		3) Error discovery
			Manticore can detect crashes and other failure cases in binaries and smart contracts
		4) Instrumentation
			Manticore provides fine-grained control of state exploration via event callbacks and instruction hooks
		5) Programmatic interface
			Manticore exposes programmatic access to its analysis engine via a Python API
45
	Echidna
	Is a Haskell program designed for fuzzing/property-based testing of Ethereum smart contracts
	It uses sophisticated grammar-based fuzzing campaigns based on a contract ABI to falsify user-defined predicates or Solidity 
	  assertions
46
	Echidna features
		1
			Generates inputs tailored to your actual code
		2
			Optional corpus collection, mutation and coverage guidance to find deeper bugs
		3
			Powered by Slither to extract useful information before the fuzzing campaign
		4
			Source code integration to identify useful information before the fuzzing campaign
		5
			Curses-based retro UI, text-only on JSON output
		6
			Automatic test case minimization for quick triage
		7
			Seamless integration into the development workflow
		8
			Maximum gas usage reporting of the fuzzing campaign
		9
			Support for a complex contract initialization with Etheno and Truffle
47
	Echidna usage
		1) Executing the test runner
			The core Echidna functionality is an executable called `echidna-test`
			`echidna-test` takes a contract and a list of invariants (properties that should always remain true) as input
			For each invariant, it generates random sequences of calls to the contract and checks if the invariant holds
			If it can find some way to falsify the invariant, it prints the call sequence that does so
			If it can't, you have some assurance the contract is safe
		2) Writing invariants
			Invariants are expressed as Solidity functions wich names that begin with `echidna_`, have no arguments, and
			  return a boolean
		3) Collecting and visualizing coverage
			After finishing a campaign, Echidna can save a coverage maximising corput in a special directory specified with
			  the corpusDir config option
			This directory will contain two entries
				1
					A directory named 'coverage' with JSON files that can be replayed by Echidna 
				2
					A plain-text file named 'covered.txt', a copy of the source code with coverage annotations
48
	`Eth-security-toolbox` is a Docker contained preinstalled and preconfigured with all of Trail of Bits' Ethereum security tools
	This includes
		1) Echidna property-based fuzz tester
		2) Etheno integration tool and differential tester
		3) Manticore symbolic analyzer and formar contract verifier
		4) Slither static analysis tool
		5) Rattle EVM lifter
		6) Not So Smart Contracts repository
49
	`Ethersplay` is a Binary Ninja Plugin which enables EVM disassembler and related analysis tool
	1
		Takes as input the evm bytecode in raw binary format
	2
		Renders control flow graph of all functions
	3
		Shows manticore coverage
50
	`Pyevmasm` is an assembler and disassembler library for the EVM
	It includes a cmdline utility and a python API
51
	`Rattle` is an EVM binary static analysis framework designed to work on deployed smart contracts (not actively developed)
	1
		Takes EVM byte strings and uses a flow-sensitive analysis to recover the original control flow graph
	2
		Lifts the control flow graph into a SSA/infinite register form, and optimizes the SSA, removing DUPs, SWAPs, PUSHs and
		  POPs
	3
		The conversion from a stack machine to a SSA form removes 60%+ of all EVM instructions and presents a much friendlier
		  interface for those who wish to read the smart contracts they're interacting with
52
	`Evm_cfg_builder` is a tool used to extract a control flow graph (CFG) frnom EVM bytecode and used by Ethersplay, Manticode
	  and other tools from ToB
		1
			Reliably recovers a Control Flow Graph (CFG) from EVM bytecode using a dedicated Value Set Analysis
		2
			Recovers function names
		3
			Recovers attributes (Eg payable, view, pure)
		4
			Outputs the CFG to a dot file
		5
			Library API
53
	`Crytic-compile` is a smart contract compilation library which is used in ToB's security tools and supports Truffle, Embark,
	  Etherscan, Brownie, Waffle, Hardhat and other development environments
	The plugin is used in Crytic tools including
		Slither
		Echidna
		Manticore
		evm-cfg-builder
54
	`solc-select` is a script to quickly switch between Solidity compiler versions
		1) `solc-select`
			Manages installing and setting different solc compiler versions
		2) `solc`
			Wrapper around `solc` which picks the right version according to what was set via `solc-select`
		3) 
			Solc binaries are downloading from `https://binaries.soliditylang.org/` which contains official artifacts
			  for many historical and modern solc versions for Linux and macOS
55 
	`Etheno` is the Ethereum testing Swiss Army Knife
	It's a JSON RPC multiplexer, analysis tool wrapper and test integration tool
		1) JSON RPC Multiplexing
			Etheno runs a JSON RPC server that can multiplex calls to one or more clients
				1
					API for filtering and modifying JSON RPC calls
				2
					Enables differential testing by sending JSON RPC sequences to multiple Ethereum clients
				3
					Deploy to and interact with multiple networks at the same time
		2) Analysis tool wrapper
			Etheno provides a JSON RPC client for advanced analysis tools like Manticode
				1
					Lowers barrier to entry for using advanced analysis tools
				2
					No need for custom scripts to set up account and contract state
				3
					Integration with Test Frameworks like Ganache and Truffle
						1
							Run a local test network with a single command
						2
							Use Truffle migrations to bootstrap Manticode analyses
						3
							Symbolic semantic annotations within unit tests
56
	`MythX` is a powerful security analysis service that finds Solidity vulns in your Ethereum smart contract code during your 
	  development lifecycle
	It is a paid API-based service which uses several tools on the backend including...
		A static analyzer (Maru)
		A symbolic analyzer (Mythril)
		A greybox fuzzer (Harvey)
	  ... to implement a total of 46 detectors
	Mythril is the open-source component of MythX
57
	MythX process
		1) Submit your code
			The analysis requests are encrypted with TLS and the code you submit is accessed only by you
			Submit both the source code and the compiled bytecode of your smart contracts for best results
		2) Activate a full suite of analysis techniques
			The longer MythX runs, the more it can detect security weaknesses
		3) Receive a detailed analysis report
			MythX detects a majority of vulns listed in the SWC registry
			The report will return a listing of all the weaknesses found in your code, including the exact position of
			  the issue and its SWC ID
			Reports generated can be only accessed by your
			MythX offers 3 scan modes, quick, standard and deep
58
	MythX tools
	When you submit your code to the API it gets analyzed by multiple microservices in parallel where these tools cooperate to
	  return the more comprehensive results in the execution time provided
		1
			A static analyzer that parses the Solidity AST
		2
			A symbolic analyzer that detects the possible vulnerable states
		3
			A greybox fuzzer that detects vulnerable execution paths
59
	MythX coverage
	Extends to most SWCs found in the SWC registry with the 46 detectors being listed here (https://mythx.io/detectors/) along with
	  the type of analysis used
60
	MythX is based on Saas (Security as a service) platform based on the premise that
		1
			Higher performance compared to running security tools locally
		2
			Higher vulnerability coverage than any standalone tool
		3
			Benefit from continious improvements to our security analysis technology with new and improved security tests
			  as the smart contract security landscape evolves	
61
	MythX privacy guarantee for the smart contract code submitted using their SaaS APIs
		1
			Code analysis requests are encrypted
		2
			To provide comprehensive reports and improve performance, it stores some of the contract data in our database,
			  including parts of the source code and bytecode but that data never leaves their secure server and is not 
			  shared with any outside parties
		3
			It keeps the results of your analysis so you can retreive them later, but the report can be accessed by only you
62
	MythX running time
	Quick scan runs for 5 minutes
	Standard scan runs for 30 minutes
	Deep scan runs for 90 minutes
63
	MythX official integrations, tools and libraries include
		1) MythX CLI
			Unified tool to use MythX as a cmdline interface now with full Truffle projects support
		2) MythX-JS
			Typescript library to integrate MythX into your JS or TS projects
		3) PythX
			Python library to integrate MythX in your Python projects
		4) MythX VSCode
			VSCode extension which allows you to scan smart contracts and view their results directly from your code editor
64
	MythX pricing
		1) On demand
			US $9.99/3 scans
			All scan modes and Prepaid scan packs
		2) Developer
			US $49/mo
			Quick and standard scan modes
			500 scans/mo
		3) Professional
			US $249/mo
			All scan modes
			10,000 scans/mo
		4) Enterprise
			Custom pricing
			Custom plans for your team's specific needs
			Custom verification service
			Retainer for Custom Support
65
	`Scribble` is a verification language and runtime verification tool that translates high-level specifications into solidity code
	It allows you to annotate a solidity smart contract with properties
		1) Principles/goals
			1
				Specifications are easy to understand by developers and auditors
			2
				Specifications are simple to reason about
			3
				Specifications can be efficiently checked using off-the-shelf analysis tools
			4
				A small number of core specification constructs are sufficient to express and reason about more advanced
				  constructs
		2) Transferms annotations in the Scribble specification language into contrete assertions
		3) With these instrumented but equivalent contracts, one can then use Mythril, Harvey, MythX
66
		Fuzzing-as-a-service is a service recently launched by ConsenSys Diligence where projects can submit their smart 
		  contracts along with embedded inlined specifications or properties written using the Scribble language
		These contracts are run through the Harvey fuzzer which uses the specified properties to optimize fuzzing campaigns
		Any violations from fuzzing are reported back from the service for the project to fix
67
	`Karl` is a monitor for SCs that checks for security vulns using the Mythril detection engine
	It can be used to monitor the Ethereum blockchain for newly deployed vulnerable SCs in real-time
68
	`Theo` is an exploitation tool with a Metasploit-like interface, drops you into a Python REPL console where you can use the
	  available features to do SC recon, check the storage, run exploits or frontrun/backrun TXs targeting a specific SC
	Features...
		Automatic SC scanning which generates a list of possible exploits
		Sending TXs to exploit a SC
		TX pool monitor
		Web3 console
		Frontrunnig and backrunning TXs
		Waiting for a list of TXs and sending out others
		Estimating gas for TXs means only successful TXs are sent
		Disabling gas estimation will send TXs with a fixed gas quantity
69
	`Visual Auditor` is a VSCode extension that provides security-aware syntax and semantic highlighting for Solidity and Vyper
		1) Syntax highlighting
			Access modifiers (external, public, payable, ...)
			Security relevant built-ins
			Globals
			Methods user/miner tainted information (address.call(), tx.origin, msg.data, block.*, now)
			Storage access modifiers (memory, storage)
			Developer notes in comments (TODO, FIXME, HACK, ...)
			Custom function modifiers
			Contract creation / event invocations
			Easily differentiate between arithmetics vs. logical operations
			Make constructor and fallback function more prominent
		2) Semantic highlighting
			Highlights StateVars (constant, inherited)
			Detects and alerts about StateVar shadowing
			Highlights function arguments in the function body
		3) Review features
			Audit annotations/bookmarks
				@audit <msg>
				@audit-ok <msg>
			Generic interface for importing external scanner results
				cdili json format
			Codelens inline action
				Graph
				Report
				Dependencies
				Inheritance
				Parse
				Ftrace
				Flatten
				Generate unittest stub
				Function signature hashes
				Uml
		4) Graph- and Reporting features
			Access your favorite Sūrya features from within VSCode
			Interactive call graphs with cgall flow highlighting and more
			Auto-generate UML diagrams from code to support your threat modelling exercises or documentation
		5) Code Augmentation
			Hover over Ethereum Account addresses to download the bytecode, sourcecode or open it in browser
			Hover over ASM instructions to show their signatures
			Hover over keywords to show basic security notes
			Hover over StateVar's to show declaration information
		6) Views
			Cockpit view and outline view (The article doesn't really go in depth)
70
	`Sūrya` aids auditors in understanding and visualizing Solidity SCs by providing information about the contracts' structure and
	  generates call graphs and inheritance graphs
	It also supports querying the function call graph in multiple ways to aid in the manual inspection of contracts
		1
			Integrated with Visual Auditor
		2
			Commands
				graph		Outputs a DOT-formatted graph of the control flow
				ftrace		Outputs a treeified function call trace stemming from the defined CONTRACT:FUNCTION
				flatten		Outputs a flattened version of the sourcecode (import statements replaced with code)
				describe	Shows a summary of the contracts and methods in the files provided
				inheritance	Outputs a DOT-formatted graph of inheritance tree
				dependencies	Outputs the c3-linearization of a given contracts inheritance graph
				parse		Outputs a treeified AST object coming from the parser
				mdreport	Created a markdown description report with tables comprising of info about contracts,
						  functions and files
						Similar to describe but with nice MD formatting
	Link https://github.com/ConsenSys/surya
71
	SWC registry
		The Smart Contract Weakness Classification Registry (SWC Registry) is an implementation of the weakness classification
		  scheme proposed in EIP-1470
		1
			It is loosely aligned to the terminologies and structure used in the Common Weakness Enumeration (CWE) while
			  overlaying a wide range of weakness variants that are specific to smart contracts
		2
			The goals of this project are as follows
				1
					Provide a straightforward way to classify security issues in smart contract systems
				2
					Define a common language for describing security issues in smart contract systems' architecture,
					  design, or code
				3
					Serve as a way to train and increase performance for smart contract security analysis tools
		3
			This repository is maintained by the team behind MythX and currently contains 37 entries
72
	Securify
	Is a security scanner for Ethereum smart contracts which implements static analysis written in Datalog and supports 38 vulns
73
	`VerX` is a verifier that can automatically prove temporal safety properties of Ethereum SCs
	The verifier is based on a careful combination of three ideas
		Reduction of temporal safety verification to reachability checking
		An efficient symbolic execution engine used to compute precise symbolic states within an TX
		Delayed abstraction which approximates symbolic states at the end of TXs into abstract states
74
	`SmartCheck` is an extensible static analysis tool for discovering vulns and other code issues in Ethereum SCs written in
	  Solidity 
	It translates Solidity source code into an XML-based intermediate representation and checks it against XPath patterns
75
	`K-Framework` based analysis, modelling and verification tools from `Runtime Verification` (RV)
	Provides `KEVM` which is a model of EVM in the X-Framework
	It is the first executable specification of the EVM that completely passes official test-suites and serves as a platform for 
	  building a wide range of analysis tools and other semantic extensions for EVM
76
	`Certora Prover` checks that a SC satisfies a set of rules written in a language called `Specify`
	Each rule is checked on all possible TXs, though of course this is not done by explicitly enumerating TXs, but rather through
	  symbolic techniques
	1
		The Certora Prover provides complete poth coverage for a set of safety rules provided by the user
		EG a rule might check that only a bounded number of tokens can be minted in an ERC20 contract
		The prover either guarantees that a rule holds on all paths and all inputs or produces a test input that demonstrates a 
		  violation of the rule
	2 
		The problem addressed by the Certora Prover is known to be undecidable which means that there will always be 
		  pathological programs and rules for which the Certora Prover will time out without a definitive answer
	3
		The Certora Prover takes as input the SC (either as EVM bytecode or Solidity source code) and a set of rules, written
		  in Certoras specification language
		The prover then automatically determines whether or not the contract satisfies all the rules using a combination of
		  two computer science techniques
			Abstract interpretation
			Constraint Solving
77
	DappHub's `HEVM` is an implementation of the EVM made specifically for unit testing and debugging smart contracts
	It can run unit tests, property tests, interactively debug contracts while showing the Solidity source, or run
	  arbitrary EVM code
78
	Capture the Flag (CTF) are furn educational challenges where participants have to hack different (dummy) smart contracts that 
	  have vulnerabilities in them
	They help understand the complexities around how vulnerabilities may be exploited in the wild
	Popular ones include
		Capture the Ether
		Ethernaut
		Damn Vulnerable Defi v2
		Paradigm CTF
79
	SC security tools are useful in assisting auditors while reviewing SCs
	They automated many of the tasks that can be codified into rules with different levels of coverage, correctness and precision
	They are fast, cheap, scalable and deterministic compared to manual analysis
	But they are also susceptible to false positives
	They are especially well-suited currently to detect common security pitfalls and best-practices at the Solidity and EVM level
	With varying degrees of manual assistance, can also be programmed to check for application-level, business-logic constraints
80
	Audit process can be thought of as a ten-step process as follows
	1
		Read specification/documentation of the project to understand the requirements, design and architecture
	2
		Run fast automated tools such as linters or static analyzers to investigate common Solidity pitfalls or missing
		  smart contract best-practices
	3
		Manual code analysis to understand business logic and detect vulnerabilities in it
	4
		Run slower but more deeper automated tools such as symbolic checkers, fuzzers, or formal verification analyzers which
		  typically require formulation of properties/constraints beforehand, hand holding during the analyses and some 
		  post-run evaluation of their results
	5
		Discuss (with other auditors) the findings from above to identify any false positives or missing analyses
	6
		Convey status to project team for clarifying questions on business logic or threat model
	7
		Iterate the above for the duration of the audit leaving some time for report writing
	8
		Write report summarizing the above with details on findings and recommendations
	9
		Deliver the report to the project team and discuss findings, severity, and potential fixes
	10
		Evaluate fixes from the project team and verify that they indeed remove the vulnerabilities identified in findings
81
	Reading specification/documentation
	For projects that have a specification of the design and architecture of their smart contracts, this is the recommended starting
	  point
	Very few new projects have a specification at the audit stage
	Some of the have documentation in parts
	Some key points...
		1
			Specification starts with the project's technical and business goals and requirements
			It describes how the project's design and architecture help achieve those goals
		2
			The actual implementation of smart contracts is a functional manifestation of the goals, requirements, 
			  specification, design and architecture, understanding of which is critical in evaluating if the implementation
			  indeed meets the goals and requirements
		3
			Documentation is a description of what has been implemented based on the design and architectural requirements
		4
			Specification answers 'why' something needs to be designed/architected/implemented the way it has been done
			Documentation answers 'how' something has been designed/achitected/implemented without necessarily addressing
			  the 'why' and leaves it up to the auditors to speculate on the reasons
		5
			Documentation is typically in the form of Readme files describing individual contract functionality combined
			  with function NatSpec and individual code comments
			Encouraging projects to provide a detailed specification and documentation saves a lot of time and effort for
			  the auditors in understanding the project's goals/structure and prevents them from making the same assumptions
			  as the implementation which is a leading cause of vulnerabilities
		6
			In the absence of both specification and documentation, auditors are forced to infer goals, requirements, 
			  design and architecture from reading code and using tools such as Surya and Slither printers
			This takes up a lot of time leaving less time for deeper/complex security analyses
82
	Running static analysers
	Automated tools such as linters or static analysers help investigate common Solidity pitfalls or missing smart contract
	  best-practices
		1
			Tools such as Slither and MythX perform control-flow and data-flow analyses on the smart contracts in the
			  context of their detectors which encode common security pitfalls and best practices
		2
			Evaluating their findings, which are usually available in seconds/minutes, is a good starting point to detect
			  common vulnerabilities based on well-known constraints/properties of Solidity language, EVM, or 
			  Ethereum blockchain
		3
			False positives are possible among some of the detector findings and need to be verified manually if they are
			  true/false positives
83
	Manual code review
	Is required to understand business logic and detect vulnerabilities in it
	1
		Automated analyzers do not understand application-level logic and their constraints
		They are limited to constraints/properties of Solidity language, EVM, or the Ethereum blockchain
	2
		Manual analysis of the code is required to detect security-relevant deviations in implementation vis-a-vis the 
		  specification or documentation
	3
		Auditors may need to infer business logic and their implied constraints directly from the code or from discussions with
		  the project team and thereafter evaluate if those constraints/properties hold in all parts of the codebase
84
	Running deeper autamated tools...
		Fuzzers 				(EG Echidna)
		Symbolic checkers 			(EG Manticore)
		Tool suite				(EG MythX)
		Formally verifying custom properties	(EG Scribble or Certora Prover)
	  ... takes more setup and preparation time but helps run deeper analyses to discover edge-cases in application-level properties
	        and mathematical errors, among other things
	1
		Given these require understanding of the project's application logic, they are recommended to be used at least after
		  an initial manual code review or sometimes after a deeper discussion about the specification/implementation
		  with the project team
	2
		Analyzing the output of these tools requires significant expertise with the tools themselves, their domain specific
		  language and sometimes even their inner workings
	3
		Evaluating false-positives is sometimes challenging with these tools but the true positives they discover are 
		  significant and extreme corner cases missed by even the best manual analyses
85
	Brainstorming with other auditors `Linus's Law`
	"Given enough eyeballs, all bugs are shallow"
	This might apply to auditors too if they brainstorm on the smart contract implementation, assumptions, findings, and vulns
	1
		While some audit firms encourage active/passibve discussion, there are others whose approach is to let auditors 
		  separately perform the assessment to encourage independent thinking instead of group thinking
		The premise is that group thinking might bias the audit team to focus on certain aspects while missing some vulns
	2
		A hybrid approach might be interesting where the audit team initially brainstorms to discuss the project's goals,
		  specification/documentation and implementation but later firewall themselves to independently pursue the 
		  assessments and finally come together to compile their findings
86
	Discussion with project team
	Having an open communication channel with the project team is useful to clarify any assumptions in specification, documentation,
	  implementation, or discuss interim findings
		1
			Findings may also be shared with the project team immediately on a private repository to discuss impact, fixes,
			  and other implications
		2
			If the audit spans multiple weeks, it may help to have a weekly sync up call
			A counterpoint to this is to independently perform the entire assessemnt so as not to get biased by the 
			  project team's inputs and opinions
87
	Report writing
	The audit report is a final compilation of the entire assessemnt and presents all aspects of the audit including the audit 
	  	Scope/coverage
		Timeline
		Team/effort
		Summaries
		Tools/techniques
		Findings
		Exploit scenarios
		Suggested fixes
		Short/long term recommendations
		Any appendecies with further details on tools and rationale
	1
		An executive summart typically gives an overview of the audit report with highlights/lowlights illustrating the 
		  number/type/severity of vulns found and an overall assessment of risk
		It may also include a description of the SCs, (inferred) actors, assets, roles, permissions, access conrol, 
		  interactions, threat model and existing risk mitigation measures
	2
		The bulk of the report focuses on the findings from the audit, their type/category, likelihood/impact, severity,
		  justifications for these ratings, potential exploit scenarios, affected parts of smart contracts and potential
		  remediations
	3
		It may also address subjective aspects of...
			Code quality
			Readability/auditability
			Other softeng best practices related to documentation
			Code structure
			Function/variable naming conventions
			Test coverage
			etc
		   ... that do not pose an imminent security risk but are indicators of anti-patterns and processes influencing the
		         introduction and persistence of security vulnerabilities
88
	Report delivery
	The delivery of the report to the projects team is a critical deliverable and milestone
	Unless interim findings/status is shared, this will be the first time the project team will have access to assessment details
	1
		The delivery typically happens via a shared online document and is accompanied with a readout where the auditors
		  present the report highlights to the project team for discussion and any debate on findings and their severity
		  ratings
	2
		The project team typically takes some time to review the audit report and respond back with any counterpoints on
		  findings, severities or suggested fixes
	3
		Depending on the prior agreement, the project team and audit firm might release the audit publicly (after all required
		  fixes have been made) or the project may decide to keep it private for some reason
89
	Evaluating fixes
	Post audit, the project team may work on any required fixes for reported findings and request the audit firm for reviewing
	  their responses
	1
		Fixes may be applied for a majority of the findings and the review may need to confirm that applied fixes (could be
		  different from audit's recommended fixes) indeed mitigate the risk reported by the findings
	2
		Findings may be contested as not being relevant, outside the project's thread model or simply acknowledged as being
		  within the project's acceptable risk model
	3
		Audit firms may evaluate the specific fixes applied and confirm/deny their risk mitigation
		Unless it is a fix/retainer type audit, this phase typically takes not more than a day because it would usually be 
		  outside the agreed upon duration of the audit
90
	Manual review approaches
	Auditors have different approaches to manual reviewing smart contract code for vulns
		Starting with access control
		Starting with asset flow
		Starting with control flow
		Starting with data flow
		Inferring constraints
		Understanding dependencies
		Evaluating assumptions
		Evaluating security checklists
91
	Starting with access control
	Access control is the most fundamental security primitive which addresses 'wh' has authorised access to 'what'
	(In a formal access control model 'who' = subjects, 'what' = objects and an access control matirx indicates permissions)
	1
		While overall philosophy might be that SCs are permissionless, in reality the do indeed have different permissions/roles
		  for differect actors who interact/use them
	2
		The general classification is that of users and admin(s)
		For purposes of guarded launch or otherwise, many smart contracts have an admin role that is typically the address
		  that deployed the contract
		Admins typically have control over critical configuration and application parameters including (emergency) transfers
		  or withdrawals of contract funds
	3
		Starting with understanding of the access control implemented by the SCs and checking if they have applied correctly, 
		  completely and consistently is a good approach to understanding access flow and detecting violations
92
	Starting with asset flow
	Assets are Ether, ERC20/ERC721/other tokens managed by smart contracts
	Given that exploits target assets of value, it makes sense to start evaluating the flow of assets into/outside/within/across
	  smart contracts and their dependencies
		1) Who
			Assets should be withdrawn/deposited only by authorized/specified addersses as per application logic
		2) When
			Assets should be withdrawn/deposited only in authorized/specified time windows or under authorized/specified
			  conditions as per application logic
		3) Which
			Assets, only those authorized/specified types, should be withdrawn/deposited as per application logic
		4) Why
			Assets should be withdrawn/deposited only for authorized/specified reasons as per application logic
		5) Where
			Assets should be withdrawn/deposited only to authorized/specified addresses as per application logic
		6) What type
			Assets, only of authorized/specified types, should be withdrawn/deposited as per application logic
		7) How much
			Assets, only in authorized/specified amounts, should be withdrawn/deposited as per application logic
93
	Evaluating control flow
	Control flow analyzes the transfer of control IE execution order, across and within smart contracts
	1
		Interprocedural (procedure is just another name of a function) control flow is typically indicated by a call graph which
		  shows which functions (callers) call which other functions (callees) acroos or within smart contracts
	2
		Intraprocedural (IE within a function) control flow is dictated by conditionals (if/else), loops (for/while/do/continue
		  /break) and return statements
	3
		Both intra and interprocedural control flow analysis help track the flow of execution and data in SCs
94
	Evaluating data flow
	Data flow analyses the transfer of data across and within SCs
	1
		Interprocedural data flow is evaluated by analyzing the data (variables/constants) used as argument values for function
		  parameters at call sites
	2
		Intraprocedural data flow is evaluated by analyzing the assignment and use of (state/memory/calldata) 
		  variables / constants along with the control flow paths within functions
	3
		Both intra and interprocedural data flow analysis help track the flow of global/local storage/memory changes in SCs
95
	Inferring constrainsts
	Program constraints are basically rules that should be followed by the program
	Language-level and EVM-level security constraints are well-known because they are part of the language and EVM specification
	However application level constraints are rules that are implicit to the busicess logic implemented and may not be explicitly
	  described in the specification 
		EG mint an ERC721 token to the address when it makes a certain deposit of ERC-20 tokens to the SC and burn it when it
		  withdraws the earlier deposit
	Such constraints may have to be inferred by the auditors while manually analyzing the SC code
	1
		One approach to inferring program constraints is to evaluate what is being done on the most program paths related to 
		  a particular logic and treat it as a constraint
		If such a constraint is missing on one of very few program paths then it could be an indicator of a vuln
		  (assuming the constraint is security related) or those program paths are exceptional conditions where the constraints
		  do not hold
	2
		Program constraints can also be verified using a symbolic checker which generates counter-examples or witnesses along
		  execution paths where such constraints do not hold
96
	Understanding dependencies
	Dependencies exist when the correct compilation or functioning of program code relies on code/data from other SCs that were
	  not necessarily developed by the project team
	1
		Explicit program dependencies are captured in the import statements and the inheritance heirarchy
		Think OpenZeppelin contracts
	2
		Composability is expected and encouraged via SCs interfacing with other protocols and vice-versa, which results in
		  emergent or implicit dependencies on the state/logic of external SCs via oracles for example
	3
		This is especially of interest/concern in DeFi protocols that rely on other related protocols for stablecoins, yield
		  generation, borrowing/lending, derivatives, oracles etc
97
	Evaluating assumptions
	Many security vulnerabilities result from faulty assumptions
	EG who can access what and when, under what conditions, for what reasons etc
	Identifying the assumptions made for the program code and evaluating if they are indeed correct can be the source of many audit
	  findings
	Some common examples of faulty assumptions are
		Only admins can all these functions
		Initialization functions will only be called once by the contract deployer (EG for upgradable contracts)
		Functions will always be called in a certain order (as expected by the specification)
		Parameters can only have non-zero values or values with a certain threshold
			EG addresses will never be zero valued
		Certain addresses or data values can never be attacker controlled
			They can never reach program locations where they can be misused
			(In program analysis literature, this is known as taint analysis)
		Function calls will always be successful and so checking for return values is not required
98
	Evaluating security checklists
	Checklisks are lists of itemized points that can be quickly and methodically followed (and referenced later by their list num)
	  to make sure all listed items have been processed according to the domain relevance
	1
		Smart contracts can hold a lot of value
		A lot of always changing and emerging
		You need to have some kind of checklist to methodically go through things
		If something slips through the crack it's bad
	2
		The help navigate the many things that need to be remembered
		They help going over the itemized features, concepts, pitfalls, best practices and examples in a methodical manner
		  without missing any items
		Checklists are known to increase retentiol and have a faster recall
99
	Presenting PoC exploits
	Exploits are incidents where vulns are triggered by malicious actors to misuse SCs (resulting in bad things like stolen assets)
	1
		Presenting PoCs of such exploits either in code or written descriptions of the scenario make audit findings more 
		  realistic and relatable by illustrating specific exploit paths and justifying severity of findings
	2
		Codified exploits should always be on a testnet, kept private and responsibly disclosed to project teams without
		  any risk of being actually executed on live systems resulting in actual bad outcomes
	3
		Descriptive exploit scenarios should make realistic assumptions or roles/powers of actors, practical reasons for their
		  actions and sequencing of events that trigger vulns and illustrate paths to exploitation
100
	Estimating the likelihood and impact
	Likelihood indicates the probability of a vulnerability being discovered by malicious actors and triggered to successfully 
	  exploit the underlying weakness
	Impact indicates the magnitude of implications on the technical and business aspects of the system if the vuln were to be
	  exploited
	Estimating if likelihood/impact are low/med/high is non-trivial in many cases
	1
		If exploit can be triggered by a few TXs manually without requiring much resources/access and without assuming many
		  conditions to hold true then it should be HIGH
		Exploits that require deep knowledge or system working or privileged roles or multiple edge conditions can be MED
		Even harder assumptions than MED would be LOW
	2
		If there is any loss or locking of fundns then impact is HIGH
		Exploits that do not affect funds but disrupt system are MED
		Anything else is LOW
	3
		Many likelihood and impact evals are contentious and debatable between audit and project teams, typically with
		  security conscious audit teams pressing for higher likelihood and impact and project teams downplaying the risks
	Estimating the severity can be done like OWASP with a matric
101
	Summary
	Audits are a time, resource and expertise bound effort where trained experts evaluate SCs using a combination of automated and 
	  manual techniques to find as many vulns as possible
	Audits can show the presence of vulns but not their absence
